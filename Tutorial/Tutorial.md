# Tutorial

**Author**: Bowen Hou

**Created Date**: 12/25/2022

This tutorial will take you through all the basic steps of using EXPH post-process code to calculate exciton-phonon 
related properties, such as exciton band structure,exciton-phonon scattering matrix and non-radiative exciton lifetime.

---
### 1. Installation and Setup
 - Installation
   - Download EXPH 
     - You can directly download [EXPH.zip](https://github.com/Qiu-Group/EXPH.git) from our github.   
     - You can also type this in your command line to get this package.:  
   ``git clone git@github.com:Qiu-Group/EXPH.git``   
    
   - Move the package to anywhere you want:  
   `mv ./EXPH ~/your_software_path/`
   - Then install EXPH:   
   `cd ~/your_software_path/EXPH/;`  
   `bash install.sh`
   - Add *./bin* to your environment:  
   `export PATH=~/your_software_path/EXPH/bin:$PATH`
 
 - Required package:
    - Install [Anaconda](https://www.anaconda.com/) firstly
 
      - Then ``conda install mpi4py``
    
    - Install [EPW](https://docs.epw-code.org/doc/DownloadAndInstall.html) (I recommend you use EPW-5.3.0 and qe-6.6, which are 
     stable from my experience)
 
 - Tutorial Example
   - Here we will go though a simple case h-BN, and all instruction below will be finished in this case:  
   `cd ~/your_software_path/EXPH/Tutorial/`  
   `unzip example.zip`  
   ``cd example``

---    

### 2. Finite-Q Exciton from BGW
In this step, we will use BGW to generate finite-Q exciton wavefunction A(c,v,S,Q,k) and exciton dispersion on a uniform 
Q-grid (such as 18\*18\*1), which will be used in later exciton-phonon matrix calculation.


- DFT (QE)  
  (1) What are we doing here?
  
  In order to diagonalize the finite-Q BSE, we need two sets of k-grid: one is unshifted k-grid and the other is shifted 
  k-grid. The shifted vector is exactly negative momentum Q of exciton.

  Since a uniform Q-grid is needed in the further exciton-phonon calculation, we need to generate a lot of shifted k-grid WFN 
  (they will be stored in *./4.2-wfnq_co-n/WFN*) corresponding to all Q points in the 1st BZ of exciton. And all finite-Q BSE 
  could share same unshifted k-grid, we only need to generate one unshifted WFN (it will be stored in *./4.1-wfn_co_fullgrid/WFN*). 
  
  It seems pretty troublesome right? Don't worry, I have already written some scripts to help you automatically doing this!
   
   BTW: I think there is no bug here, but please do sanity check for every step and contact Bowen if you find anything weired.
  
  (2) Practical Steps

  - `cd 3-exciton-band/1-mf`, and you will find 6 files:
    - ***in_head***: input of pw.x for unshifted k-grid (you can treat this as *2.1-wfn/* of standard Q=0 calculation). There is **no** 
    'KPOINTS' set in this file, which will be generated by script automatically (so this file is called 'in_**head**'). If you 
    want to set kpoints by yourself to do sanity check or debug, please **DO NOT** apply symmetry. Symmetry might introduce some unknown issue.
    - ***inq_head***: input of pw.x for shifted k-grid. You don't have to set *KPOINTS* by yourself either, my script will help you
    automatically setting it based on what you write in *kpt.dat*. (usually, nbnd= number_of_valence_bands + 2)
    - ***pp_in***: input of pw2bgw.x for unshfited k-grid (for in_head)
    - ***pp_inq***: input of pw2bgw.x for shifted k-grid (for inq_head)
    - ***kpt.dat***: list of all shift vectors, which is corresponding to **Q-points** you want to calculate later 
    (usually, this is a uniform grid, e.g. here is a 3\*3\*1 Q(negative shift)-grid). Remember: **do not apply symmetry** due to some gauge issue
    (further study needed here)  
    **NOTE:** You can put any Q-point path in this kpt.dat, it is not necessary a uniform Q-grid (uniform Q-grid only works for further 
    exciton-phonon interaction). For example, you can put high-symmetry Q-points path here to calculate exciton band dispersion.
    - ***kgrid.inp***: input of kgrid.x, used to generate unshifted kgrid. Empirically, 24\*24\*1 is good enough to converge 
    MoS2 BSE calculation.
    
  - Firstly run DFT calculation for 2.1-wfn and 2.2-wfnq (Please modify QEPATH and BGWPATH in *go0.sh*.). This step is used to generate WFN to do inteqp.cplx.x in the 
  later finite-Q exciton calculation (BSE with different Q needs different eqp.dat, which is generated by interpolating eqp.dat for 
  shifted gird based on unshifted grid.).  
  `sbatch go0.sh`  
  this may last 30s if you use -N 2 -n 112.  
   **In reality, you can link the directory you have done in the standard
  GW+BSE calculation, and you don't have to redo it**
  - execute this in command line:  
  `finite_any_Q_DFT.py`  
  it will automatically make DFT directories including different shifted and unshifted input. Go to several files to doublecheck if everything seems normal.
  - run DFT calculation (modify number of nodes, number of mpi-task and QE path before you run it):  
  `sbatch go.sh`  
  this may last 2 minutes if you use -N 10 -n 560
  
 
- GW + BSE (BGW)  
  (1) What are we doing in this step?
 
  In this step, we will generate finite-Q exciton wavefunction by diagonalizing finite-Q BSE based on Q-points you set in
  */3-exciton-band/1-mf/kpt.dat*. Note: this step is really **expensive**, please make sure everything is right before you 
  do it.
  
  (2) Practical Steps
  
  - `cd 3-exciton-band/2-bgw/` and you will find 2 directories:  
    - ***1-epsilon***: this directory includes *epsmat.h5* and *eps0mat.h5*, which will be used in later BSE. Please do this
    calculation with a **small** cutoff energy (e.g. 7 Ry) with WFN generated in *../1-mf/2.1-wfn* and *../1-mf/2.2-wfnq* (but 
    you don't need to do that in this example).     
    **IMPORTANT**: please recalculate this with a very small cutoff energy (e.g. 7 Ry), even if you have already generated
    1-epsilon in your standard calculation. Because BSE calculation is pretty expensive, if you use epsmat.h5 generated in
    your standard calculation with large cutoff (25 Ry e.g.), it will make finite Q exciton calculation impossible to be finished
    (we usually need 24\*24\*1 Q-grid i.e. 576 BSE calculation). However, luckily BSE calculation is not sensitive to cutoff
    energy in epsmat.h5 (I have also verified it), so we can use *epsmat.h5* with small cutoff energy safely.
    - ***2-bgw***: this directory includes *eqp.dat*, which will be used in later for interpolation. Luckily, you don't have 
    to recalculate it, just use your standard GW result (make sure k-grid here is the same as *../1-mf/2.1-wfn*).
  
  - execute this in command line to generate necessary directories and input files (the first "2" is number of conduction bands
  in kernel.inp and the second "2" is number of valence band in kernel.inp):  
  `finite_any_Q_BSE.py 2 2`
  
  - go to *./5-exciton-Q* just generated by finite_an_Q_BSE.py  
  `cd ./5-exciton-Q`  
  and you will find a bunch of directories including *inteqp* and *Q-n*.
    - ***kpt***: Q-shift for this BSE
    - ***inteqp***: this includes interpolated eqp.dat for *4.1-wfn_co_fullgrid/WFN*, which will be referred as *eqp_co.dat* later
    - ***Q-n***: BSE for each finite Q-exciton
      - ***5.0-inteqp-Q***: this includes interpolated eqp.dat for *4.2-wfnq_co-9/WFN*, which will be referred as *eqp_co_q.dat* later
      - ***5.1-kernel-Q***: finite Q-exciton BSE kernel
      - ***5.2-absorp-Q***: this will generate eigenvector.h5 file for
  
  - run finite-Q exciton BSE (before you run, modify path and parallel parameters.):    
  ``sbatch go.sh``  
  it might last 8 minutes if you use -N 10 -n 560
  
  - collect all data to acvs.save  
  ``collect.py acv 9``  
  where acv denotes this is for acvs.save and 9 denotes the number of Q points (here, we calculate 3\*3\*1 = 9 Q points)  
  **NOTE:** You can also go back to last directory (`cd ../`) and run ``finite_Q_get_data.py 1 576``. Then you will have 
  **xc_nS.dat** and **kpt_crystal.dat** in *5-exciton-Q*. This function is pretty useful to do debugging.

  By now, we have finished all calculation for finite-Q exciton! The next step is to do EPW calculation.  
  ``cd ../../../4-epw/``
    
### 3. Electron-Phonon Matrix from EPW
(1) What are we doing here ?  

In this step, we will use EPW (**please see their [tutorial](https://epw-code.org/) here! Contact Bowen for more tutorial material or 
if you encounter any issue**) to generate electron-phonon matrix g(k,q,m,n,lambda), which will be used in later 
exciton-phonon matrix calculation. In this example, I have prepare all input file for you and our calculation follows:
SCF -> Phonon(DFPT) -> NSCF -pp.py-> EPW (carefully see every input file and go.sh in *./4-epw/* for details).  
 **NOTE:** pp.py has two input parameter, the first one is prefix of system (here is bn), and the second one "3" denotes 
 the number of q-point of phonon calculation (you can usually find this from ph.out)

(2) Practical Step
 - Run Calculation for Electron-Phonon Matrix (modify go.sh based on your need, such as path and nodes number)  
 ``sbatch go.sh``  
 this step will take about 2 minutes with -N 1 -n 9   
 **Note:** when you are doing epw calculation in reality, you could divide it into two parts: Wannier and elph. The number of mpitask 
 you are using for Wannier should not be more than the number of full-q points of system (here is 9), otherwise, it will
 raise error. If you finish Wannier calculation, just set wannierize    = .false. , then you could use more mpitask. No worry here,
 just run go.sh.
  
 - collect data to gkk.save  
 ``collect.py gkk 6``  
 where gkk denotes this is for gkk.save and 6 is number of phonon mode (here we have 2 atoms, so nmode=6)

By now, we have finished all calculation for finite-Q exciton! The next step is to do EPW calculation.   
  ``cd ../5-exph/`` 

### 4. Exciton-Phonon Interaction
(1) What are we doing here ?  

In this step, we will use EXPH post-process code to calculate exciton-phonon related quantities. Here are important key words
in exph.in (input file of exph.py):  
> **valence_start_gkk**: the lowest band index in el-ph calculation. (find this from epw.out)
>  
> **conduction_end_gkk:** the hiest band index in el-ph calculation. (find this from epw.out)  
>
> **T**: temperature  
>
> **degaussian**: the broadening of sigma function (the smaller the better, but you have to do convergence test with interpolated
> Q-points, you can find some information [here](https://github.com/Qiu-Group/EXPH/blob/master/README.md))  
>
> **initialize**: initialize the system, generate necessary files and check everything before real calcualtion  
>
> **xct_scattering_rate**: calculate xct_scattering_rate for one exciton state (S,Q), set S and Q in the following lines in 
> exph.in. This step is usually used for convergence test and a small test before lifetime calculation over the 1st BZ. For
> convergence test, see [here](https://github.com/Qiu-Group/EXPH/blob/master/README.md)  
> 
> **xct_lifetime_all_BZ**: calculate lifetime of specified exciton band (S) over the 1s BZ,, where S is set in the following line  
> 
> **plot_***: You can use EXPH to plot or get data then plot by yourself.   
> 
> **NOTE**: parallel is only available for xct_scattering_rate and xct_lifetime_all_BZ. See parallel efficiency [here](https://github.com/Qiu-Group/EXPH/blob/master/README.md)   

(2) Practical Step
  - collect accvs.save and gkk.save save  
  ``mkdir save``  
  ``cp -r ../3-exciton-band/2-bgw/5-exciton-Q/acvs.save ./save``  
  ``cp -r ../4-epw/gkk.save ./save``
  
  - Initialize system:  
  Set **initialize =True**   
  run ``exph.py``   
  In this step, EXPH code will generate necessary kpt map, band map, gkk.h5 and acvs.h5 files. And
  this step will check if information in acvs.save and gkk.save match with each other (since they are calculated from
  two different softwares, we need to do this double check)
    - ***gkk.h5***: includes el-ph matrix and some system information
    - ***acvs.h5***: includes eigenvector and eigenvalue of finite-Q exciton and other mean field calculation information

  - Calculate Exciton Scattering Rate for (S=1, Q=1):  
  Set **initialize =False**   
  Set **xct_scattering_rate = True**  
  Turn on interactive session: ``idev``  
  run `ibrun -np 9 exph.py`
  
  - Calculate Exciton Lifetime over the 1st BZ for (S=1): 
    Set **xct_scattering_rate = False** 
    Set **xct_lifetime_all_BZ = True**
    run `ibrun -np 9 exph.py`
    
---
Please contact Bowen Hou ([bwhou.hou@yale.edu](bwhou.hou@yale.edu)) If you have any question. Thanks.