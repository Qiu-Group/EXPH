import math
import matplotlib.pyplot as plt
import os
import shutil
import numpy as np

def get_poscar():
    poscar_name = 'POSCAR'
    poscar_data_raw = open(poscar_name, 'r')
    poscar_data = poscar_data_raw.readlines()    #processed poscar data
    atom_name = poscar_data[5].split()
    atom_number = poscar_data[6].split()
    [atom_information, position, atom_dic] = [[], [] , {}]
    lattice =  []
    for ia in range(3):
        temp5 = poscar_data[ia+2].split()
        temp6 = []
        for i in temp5:
            temp6 = temp6 + [float(i)]
        lattice = lattice + [tuple(temp6)]
    for i in range(len(atom_name)):   #[(atom1,number),...]
        temp = [(atom_name[i], int(atom_number[i]))]
        atom_information = atom_information + temp
        temp = []
    for ii in range(len(poscar_data)-8): #position = [(a1,b1,c1),...]
        temp  = []
        temp1 = []
        temp = poscar_data[ii+8].split()
        for j in range(len(temp)):
            temp1 = temp1 + [float(temp[j])]
        position = position + [tuple(temp1)]
    for jj in range(len(atom_name)):
        [temp2, temp3, index] = [[], [], 0] #temp2 is name of atom; temp3 is corresponding section of such atom positions
        temp2 = atom_information[jj][0]
        for ij in range(jj+1):
            index = index + atom_information[ij][1]
        index0 = index - atom_information[jj][1]
        temp3 = position[index0: index]
        atom_dic[temp2] = temp3
    return atom_dic, lattice
# input: number of POSCAER
# read POSCAR information
# output: atom_dic = {'atom1':[(atom1_1_x, atom_1_y, atom_1_z), (atom1_2_x, atom_2_y, atom_2_z), ...], ...}
#         lattice = [(a1,b1,c1),(a2,b2,c2),(a3,b3.c3)]

def f_2_c(fractial, lattice):
    [A, B, C] = [np.array(lattice[0]), np.array(lattice[1]), np.array(lattice[2])]
    return tuple(fractial[0]*A + fractial[1]*B + fractial[2]*C)
# input: the fractial and lattice
# output: cartesian coordiante

def project(vec1, vec2):
    return float(np.dot(np.array(vec1), np.array(vec2))/float(np.linalg.norm(np.array(vec2)))**2)
# output project vec1 to vec2 with fractional coordiantes

def c_2_f(cartesian, lattice):
    return (project(cartesian, lattice[0]), project(cartesian, lattice[1]), project(cartesian, lattice[2]))

def rotate(vec1, sita):
    return (math.cos(sita)*vec1[0]-math.sin(sita)*vec1[1], math.sin(sita)*vec1[0]+math.cos(sita)*vec1[1], 0)

def frac_2_cart():
    atom_dic, lattice = get_poscar()
    atom_dic_car = {}
    for i in atom_dic: # i = 'Cu'...
        temp0 = []
        for j in atom_dic[i]: # j = (a1,a2,a3)
            temp0 = temp0 + [f_2_c(j, lattice)]
        atom_dic_car[i] = temp0
    return atom_dic_car, lattice
# output: atom_dic_car is an atom dictionary with cartesian coordinates
# tanverse the fractial coordiante of atom to cartesian coordiante.

def translate():
    atom_dic_car, lattice = frac_2_cart()
    atom_dic_car_pool = {}
    for i in atom_dic_car:
        temp1 = []
        for j in atom_dic_car[i]:
            temp1 = temp1 + [j, tuple(np.array(j)+np.array(lattice[0])), tuple(np.array(j)-np.array(lattice[0])),
                             tuple(np.array(j)+np.array(lattice[1])), tuple(np.array(j)-np.array(lattice[1])),
                             tuple(np.array(j)+np.array(lattice[1])+np.array(lattice[0])), tuple(np.array(j)-np.array(lattice[1])+np.array(lattice[0])),
                             tuple(np.array(j)+np.array(lattice[1])-np.array(lattice[0])), tuple(np.array(j)-np.array(lattice[1])-np.array(lattice[0]))]
        atom_dic_car_pool[i] = temp1
    return atom_dic_car_pool, lattice

def filter():
    atom_dic_car_pool, lattice = translate()
    A = list(np.array(lattice[0]) - np.array(lattice[1]))
    B = list(np.array(lattice[0]) + np.array(lattice[1]))
    atom_dic_car_filter = {}
    for i in atom_dic_car_pool:
        temp2 = []
        for j in atom_dic_car_pool[i]:
            if 0 <= round(project(j, A), 5) < 1:
                if 0 <= round(project(j, B), 5) < 1:
                    temp2 = temp2 + [c_2_f(j, [A, B, lattice[2]])]
        atom_dic_car_filter[i] = temp2
        sita = math.atan(A[1]/A[0])
        A1 = rotate(A, -sita)
        B1 = rotate(B, -sita)
    return atom_dic_car_filter, [A1, B1, lattice[2]]

def wirte_poscar():
    atom_dic, lattice = filter()
    with open('../../../../00-技术细节/技术tutorial/POSCAR_2_Cubic/POSCAR_cubic', 'w') as f:
        f.write('generated by bw\n1.0000000000\n')
    with open('../../../../00-技术细节/技术tutorial/POSCAR_2_Cubic/POSCAR_cubic', 'a') as f:
        for i in lattice:
            f.write('%.9f %.9f %.9f \n' % (i[0], i[1], i[2]))
        for i in atom_dic:
            f.write('%s ' % i)
        f.write('\n')
        for i in atom_dic:
            f.write('%s ' %(len(atom_dic[i])))
        f.write('\ndirect\n')
        for i in atom_dic:
            for ii in range(len(atom_dic[i])):
                f.write('%.5f %.5f %.5f \n' % (atom_dic[i][ii][0], atom_dic[i][ii][1], atom_dic[i][ii][2]))




if __name__ == '__main__':
    #atom_dic, lattice = get_poscar()
    print('\nBBBBBBB      HH       HH\nBB     B     HH       HH\nBB    BB     HH       HH\nBBBBBB       HH H H H HH\nBB    BB     HH       HH\nBB     B     HH       HH\nBBBBBBB      HH       HH  o\n')
    atom_dic_car, lattice =  frac_2_cart()
    atom_dic, lattice = get_poscar()
    atom_dic_car_pool, lattice = translate()
    atom_dic_car_filter, lattice = filter()
    wirte_poscar()
